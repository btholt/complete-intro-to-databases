{"componentChunkName":"component---src-templates-lesson-template-js","path":"/redis-command-options","result":{"data":{"markdownRemark":{"html":"<h2 id=\"nx-and-xx\" style=\"position:relative;\"><a href=\"#nx-and-xx\" aria-label=\"nx and xx permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NX and XX</h2>\n<p>These allow you to tell Redis \"fail if this key already exists\" or \"fail if this key doesn't already exists\". Occasionally this can be helpful.</p>\n<p>Note the <code class=\"language-text\">#</code> comments aren't valid so don't copy and paste those parts.</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET color blue XX # fails because it doesn&#39;t exist yet\nSET color blue NX # succeeds because it didn&#39;t exist\nSET color blue XX # succeeds because it does exist\nSET color blue NX # fails because it does exist</code></pre></div>\n<p>Just thing that <code class=\"language-text\">NX</code> is succeeds when <strong>n</strong>ot e<strong>x</strong>ists and <code class=\"language-text\">XX</code> is the other one.</p>\n<p>You could actually re-implement our plane explorer above with this.</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET plane:0:0 visited NX # succeeds\nSET plane:1:0 visited NX # succeeds\nSET plane:0:0 visited NX # fails\nSET plane:1:1 visited NX # succeeds</code></pre></div>\n<p>And now you can just track if a read/write fails or succeeds to know if you've been there before.</p>\n<h2 id=\"ttl\" style=\"position:relative;\"><a href=\"#ttl\" aria-label=\"ttl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TTL</h2>\n<p>TTL stands for <strong>t</strong>ime <strong>t</strong>o <strong>l</strong>ive. The idea here is you can put an expiration on a key in Redis and after that time Redis will automatically clean up the record for you. MongoDB and PostgreSQL also possess this ability but it becomes essential to caching.</p>\n<p>Let's say you run a fitness app and a user wants to see all their fitness statistics for their workouts. Let's say this calculation is fairly expensive to do so it'd be better if we didn't do it multiple times a minute if a user refreshes the page. And typically that data doesn't update so frequently; people don't work out all the time. Yet after an hour or so that data is stale: our users want to see fairly up to date information. We could do this:</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET fitness:total:btholt 750kj EX 3600</code></pre></div>\n<p>This will set the key of <code class=\"language-text\">fitness:total:btholt</code> to expire after an hour after which it'll delete itself. Think of <code class=\"language-text\">EX</code> meaning expires. EX is always in seconds. Then in your code you'll first try to grab the cache. If something is there, it means it's still valid so go ahead and serve that. If it's not there, it means you need to recalculate it and you go ahead and do it right then.</p>\n<p>There is also <code class=\"language-text\">PX</code> if you need milliseconds.</p>\n<p>If you want to see it in action, try this.</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET test_expire hi EX 5\nEXISTS test_expire</code></pre></div>\n<h2 id=\"thundering-herd\" style=\"position:relative;\"><a href=\"#thundering-herd\" aria-label=\"thundering herd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thundering herd</h2>\n<p>A word of caution: the <em>thundering herd</em> problem is something to consider. Let's say that 1,000 users hit that page all at the same time when the cache has expired. Our server will miss the cache 1,000 times and try to calculate the response 1,000 times. This is referred to as the thundering herd problem. Caching is difficult business. It's not a huge possibility here because we're just targeting one user but if it was a real possibility that multiple users could hit a cache miss then you need to mitigate that. A good way is that the server <em>only</em> reads from the cache and then a separate background job updates the cache automatically (and thus you wouldn't use TTLs at all.)</p>\n<p>After five seconds EXISTS will return false. Very useful for all sorts of caching strategies.</p>","frontmatter":{"path":"/redis-command-options","title":"Redis Command Options","order":"5C","section":"Key-Value Store","description":""}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"2F","path":"/aggregation","title":"Aggregation"}}},{"node":{"frontmatter":{"order":"4D","path":"/complex-neo4j-queries","title":"Complex Neo4j Queries"}}},{"node":{"frontmatter":{"order":"3D","path":"/complex-sql-queries","title":"Complex SQL Queries"}}},{"node":{"frontmatter":{"order":"6A","path":"/conclusion","title":"Conclusion"}}},{"node":{"frontmatter":{"order":"4A","path":"/graph-databases","title":"Graph Databases"}}},{"node":{"frontmatter":{"order":"3H","path":"/hasura","title":"Hasura"}}},{"node":{"frontmatter":{"order":"2E","path":"/indexes-in-mongodb","title":"Indexes in MongoDB"}}},{"node":{"frontmatter":{"order":"1B","path":"/installation-notes","title":"Installation Notes"}}},{"node":{"frontmatter":{"order":"3A","path":"/intro-to-sql-databases","title":"Intro to SQL Database"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"3E","path":"/json-in-postgresql","title":"JSON in PostgreSQL"}}},{"node":{"frontmatter":{"order":"5A","path":"/key-value-store","title":"Key-Value Store"}}},{"node":{"frontmatter":{"order":"2H","path":"/mongodb-ops","title":"MongoDB Ops"}}},{"node":{"frontmatter":{"order":"2B","path":"/mongodb","title":"MongoDB"}}},{"node":{"frontmatter":{"order":"5E","path":"/more-redis-concepts","title":"More Redis Concepts"}}},{"node":{"frontmatter":{"order":"4C","path":"/neo4j-browser","title":"Neo4j Browser"}}},{"node":{"frontmatter":{"order":"4E","path":"/neo4j-indexes","title":"Indexes in Neo4j"}}},{"node":{"frontmatter":{"order":"4G","path":"/neo4j-ops","title":"Neo4j Ops"}}},{"node":{"frontmatter":{"order":"4B","path":"/neo4j","title":"Neo4j"}}},{"node":{"frontmatter":{"order":"2G","path":"/nodejs-app-with-mongodb","title":"Write a Node.js app with MongoDB"}}},{"node":{"frontmatter":{"order":"4F","path":"/nodejs-app-with-neo4j","title":"Node.js App with Neo4j"}}},{"node":{"frontmatter":{"order":"3G","path":"/nodejs-app-with-postgresql","title":"Node.js App with PostgreSQL"}}},{"node":{"frontmatter":{"order":"5F","path":"/nodejs-app-with-redis","title":"Node.js App with Redis"}}},{"node":{"frontmatter":{"order":"2A","path":"/nosql","title":"NoSQL"}}},{"node":{"frontmatter":{"order":"3F","path":"/postgresql-indexes","title":"Indexes in PostgreSQL"}}},{"node":{"frontmatter":{"order":"3I","path":"/postgresql-ops","title":"PostgreSQL Ops"}}},{"node":{"frontmatter":{"order":"3B","path":"/postgresql","title":"PostgreSQL"}}},{"node":{"frontmatter":{"order":"2C","path":"/querying-mongodb","title":"Querying MongoDB"}}},{"node":{"frontmatter":{"order":"3C","path":"/querying-postgresql","title":"Querying PostgreSQL"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-command-options","title":"Redis Command Options"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-data-types","title":"Redis Data Types"}}},{"node":{"frontmatter":{"order":"5G","path":"/redis-ops","title":"Redis Ops"}}},{"node":{"frontmatter":{"order":"5B","path":"/redis","title":"Redis"}}},{"node":{"frontmatter":{"order":"1C","path":"/terminology","title":"Terminology"}}},{"node":{"frontmatter":{"order":"2D","path":"/updating-mongodb","title":"Updating MongoDB"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}