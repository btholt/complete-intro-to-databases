{"componentChunkName":"component---src-templates-lesson-template-js","path":"/postgresql-indexes","result":{"data":{"markdownRemark":{"html":"<p>This works very similarily to how it works in MongoDB so we're going to breeze over this pretty quickly.</p>\n<p>Let's take this query:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> comment_id<span class=\"token punctuation\">,</span> user_id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">time</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">LEFT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">comment</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> comments <span class=\"token keyword\">WHERE</span> board_id <span class=\"token operator\">=</span> <span class=\"token number\">39</span> <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> <span class=\"token keyword\">time</span> <span class=\"token keyword\">DESC</span> <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This should be a pretty common query if we're making a message board: grab all the comments for a particular board. Let's see what PostgreSQL does under the hood by adding an <code class=\"language-text\">EXPLAIN</code> in front of it.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> comment_id<span class=\"token punctuation\">,</span> user_id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">time</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">LEFT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">comment</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> comments <span class=\"token keyword\">WHERE</span> board_id <span class=\"token operator\">=</span> <span class=\"token number\">39</span> <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> <span class=\"token keyword\">time</span> <span class=\"token keyword\">DESC</span> <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This part should break your heart: <code class=\"language-text\">Seq Scan on comments</code>. This means it's looking at every comment in the table to find the answer. This is a place we'd need an index to prevent this. Let's make an index on board_ids to speed this up.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> <span class=\"token keyword\">ON</span> comments <span class=\"token punctuation\">(</span>board_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> comment_id<span class=\"token punctuation\">,</span> user_id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">time</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">LEFT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">comment</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> comments <span class=\"token keyword\">WHERE</span> board_id <span class=\"token operator\">=</span> <span class=\"token number\">39</span> <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> <span class=\"token keyword\">time</span> <span class=\"token keyword\">DESC</span> <span class=\"token keyword\">LIMIT</span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">-- run again</span></code></pre></div>\n<p>If you're looking the EXPLAIN again, you'll see it does a <code class=\"language-text\">Bitmap Heap Scan</code> instead of a Seq Scan. Much better!</p>\n<p>Let's do one more; all users should have a unique username. Let's ensure that with a unique index.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">INDEX</span> username_idx <span class=\"token keyword\">ON</span> users <span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> users <span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span> email<span class=\"token punctuation\">,</span> full_name<span class=\"token punctuation\">,</span> created_on<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'aaizikovj'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'lol@example.com'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Brian Holt'</span><span class=\"token punctuation\">,</span> <span class=\"token function\">NOW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">-- this will fail</span></code></pre></div>\n<ul>\n<li>The <code class=\"language-text\">username_idx</code> is just a name for the index. You can call it whatever you want.</li>\n<li>Try inserting a duplicate username. The query will fail.</li>\n<li>A pleasant byproduct is that this field is now indexed so you can easily search it.</li>\n</ul>\n<p>PostgreSQL has <a href=\"https://www.postgresql.org/docs/13.0/indexes.html\">more types of indexes</a>. Feel free to explore them more.</p>","frontmatter":{"path":"/postgresql-indexes","title":"Indexes in PostgreSQL","order":"3F","section":"SQL","description":"Indexes are critical to a well functional relational database. Brian quickly explains how to investigate query performance and how to create an index to solve that problem."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"2F","path":"/aggregation","title":"Aggregation"}}},{"node":{"frontmatter":{"order":"4D","path":"/complex-neo4j-queries","title":"Complex Neo4j Queries"}}},{"node":{"frontmatter":{"order":"3D","path":"/complex-sql-queries","title":"Complex SQL Queries"}}},{"node":{"frontmatter":{"order":"6A","path":"/conclusion","title":"Conclusion"}}},{"node":{"frontmatter":{"order":"4A","path":"/graph-databases","title":"Graph Databases"}}},{"node":{"frontmatter":{"order":"3H","path":"/hasura","title":"Hasura"}}},{"node":{"frontmatter":{"order":"2E","path":"/indexes-in-mongodb","title":"Indexes in MongoDB"}}},{"node":{"frontmatter":{"order":"1B","path":"/installation-notes","title":"Installation Notes"}}},{"node":{"frontmatter":{"order":"3A","path":"/intro-to-sql-databases","title":"Intro to SQL Database"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"3E","path":"/json-in-postgresql","title":"JSON in PostgreSQL"}}},{"node":{"frontmatter":{"order":"5A","path":"/key-value-store","title":"Key-Value Store"}}},{"node":{"frontmatter":{"order":"2H","path":"/mongodb-ops","title":"MongoDB Ops"}}},{"node":{"frontmatter":{"order":"2B","path":"/mongodb","title":"MongoDB"}}},{"node":{"frontmatter":{"order":"5E","path":"/more-redis-concepts","title":"More Redis Concepts"}}},{"node":{"frontmatter":{"order":"4C","path":"/neo4j-browser","title":"Neo4j Browser"}}},{"node":{"frontmatter":{"order":"4E","path":"/neo4j-indexes","title":"Indexes in Neo4j"}}},{"node":{"frontmatter":{"order":"4G","path":"/neo4j-ops","title":"Neo4j Ops"}}},{"node":{"frontmatter":{"order":"4B","path":"/neo4j","title":"Neo4j"}}},{"node":{"frontmatter":{"order":"2G","path":"/nodejs-app-with-mongodb","title":"Write a Node.js app with MongoDB"}}},{"node":{"frontmatter":{"order":"4F","path":"/nodejs-app-with-neo4j","title":"Node.js App with Neo4j"}}},{"node":{"frontmatter":{"order":"3G","path":"/nodejs-app-with-postgresql","title":"Node.js App with PostgreSQL"}}},{"node":{"frontmatter":{"order":"5F","path":"/nodejs-app-with-redis","title":"Node.js App with Redis"}}},{"node":{"frontmatter":{"order":"2A","path":"/nosql","title":"NoSQL"}}},{"node":{"frontmatter":{"order":"3F","path":"/postgresql-indexes","title":"Indexes in PostgreSQL"}}},{"node":{"frontmatter":{"order":"3I","path":"/postgresql-ops","title":"PostgreSQL Ops"}}},{"node":{"frontmatter":{"order":"3B","path":"/postgresql","title":"PostgreSQL"}}},{"node":{"frontmatter":{"order":"2C","path":"/querying-mongodb","title":"Querying MongoDB"}}},{"node":{"frontmatter":{"order":"3C","path":"/querying-postgresql","title":"Querying PostgreSQL"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-command-options","title":"Redis Command Options"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-data-types","title":"Redis Data Types"}}},{"node":{"frontmatter":{"order":"5G","path":"/redis-ops","title":"Redis Ops"}}},{"node":{"frontmatter":{"order":"5B","path":"/redis","title":"Redis"}}},{"node":{"frontmatter":{"order":"1C","path":"/terminology","title":"Terminology"}}},{"node":{"frontmatter":{"order":"2D","path":"/updating-mongodb","title":"Updating MongoDB"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}