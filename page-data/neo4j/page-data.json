{"componentChunkName":"component---src-templates-lesson-template-js","path":"/neo4j","result":{"data":{"markdownRemark":{"html":"<p>Let's get our database up and running! Run the following.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run -dit --rm --name<span class=\"token operator\">=</span>my-neo4j -p <span class=\"token number\">7474</span>:7474 -p <span class=\"token number\">7687</span>:7687 --env<span class=\"token operator\">=</span>NEO4J_AUTH<span class=\"token operator\">=</span>none neo4j:4.1.3</code></pre></div>\n<p>This will spin up a new instance of Neo4j in docker and expose both its HTTP client and its querying port. We're going to start by querying the commandline called <code class=\"language-text\">cypher-shell</code> and then we'll move on to the awesome browser experience.</p>\n<p>First thing to know is that the database is called Neo4j and the query language is called Cypher, just like the database is PostgreSQL and the query language is SQL. There are other graph query langauges like Gremlin but we'll just be talking Cypher today.</p>\n<p>So let's get connected. Run the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token builtin class-name\">exec</span> -it my-neo4j cypher-shell</code></pre></div>\n<p>This should drop you into an interactive with Neo4j. The first thing we're going to do is use a CREATE statement to make our first actor, Michael Cera. I love the movie Scott Pilgrim vs. the World so we're going to describe the actors in it here.</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">CREATE (Person {name:&#39;Michael Cera&#39;, born:1988});</code></pre></div>\n<p>You can see we created a new node with a label of Person and two attributes: a name of Michael Cera and a birth year of 1988. CREATE (Person {name:'Michael Cera', born:1988});</p>\n<p>Now what if we want to find that same record?</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">MATCH (p {name: &quot;Michael Cera&quot;}) RETURN p;</code></pre></div>\n<ul>\n<li>Now we're using a shorthand variable, <code class=\"language-text\">p</code>. We could call this anything.</li>\n<li>The first part reprsents what we're querying for. We didn't specify what label it was going to be but we have. Then it would look like <code class=\"language-text\">MATCH (p {name: &quot;Michael Cera&quot;}) RETURN p;</code></li>\n<li>You need the return at the end or you wouldn't get anything back.</li>\n</ul>\n<p>Let's create a movie and then query for it.</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">CREATE (m:Movie {title: &#39;Scott Pilgrim vs the World&#39;, released: 2010, tagline: &#39;An epic of epic epicness.&#39; }) RETURN m;</code></pre></div>\n<ul>\n<li>This will create and return all in the same query because there's no semicolon so it's treated as one query.</li>\n<li>It's easy to make big complicated queries with Cypher.</li>\n</ul>\n<p>Let's now make them associated with each other so that Michael Cera acted in Scott Pilgrim vs the World.</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">MATCH (Michael:Person),(ScottVsWorld:Movie)\nWHERE Michael.name = &quot;Michael Cera&quot; AND ScottVsWorld.title = &quot;Scott Pilgrim vs the World&quot;\nCREATE (Michael)-[relationship:ACTED_IN {roles:[&quot;Scott Pilgrim&quot;]}]-&gt;(ScottVsWorld)\nRETURN relationship;</code></pre></div>\n<ul>\n<li>The first match says we're looking for two separate things, a Person and a Movie.</li>\n<li>We then give a WHERE (there are a few ways to write queries that all work).</li>\n<li>We then identify that we're going to CREATE something new.</li>\n<li>This reads like ASCII art You have (node) - [RELATIONSHIP] -> (node). This identifies that Michael ACTED<em>IN Movie. The -> identifies the direction of the relationship. We also can totally right it as (Scott Pilgrim vs the World) &#x3C;- [ACTED</em>IN] - (Michael Cera). Both work.</li>\n<li><code class=\"language-text\">relationship</code> is a variable that refers to the new relationship we just created. It's optional but I wanted to return it at the end.</li>\n<li>Neo4j recommends you do CapitalCasing with label names (like Person and Movie) and that you SCREAMING<em>CASE relationship types (like DIRECTED and ACTED</em>IN.) I just follow their recommendations. <a href=\"https://neo4j.com/docs/cypher-manual/4.1/syntax/naming/\">See here</a>.</li>\n</ul>\n<p>Okay, so let's put a few more relationships to the movie in. Copy/paste this to add a few more actors, actresses, and the director. (How many good actors and actresses were in Scott Pilgrim!?)</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">MATCH (ScottVsWorld:Movie) WHERE ScottVsWorld.title = &quot;Scott Pilgrim vs the World&quot;\nCREATE (Anna:Person {name:&#39;Anna Kendrick&#39;, born:1985})\nCREATE (Brie:Person {name:&#39;Brie Larson&#39;, born:1989})\nCREATE (Aubrey:Person {name:&#39;Aubrey Plaza&#39;, born:1984})\nCREATE (Mary:Person {name:&#39;Mary Elizabeth Winstead&#39;, born:1984})\nCREATE (Kieran:Person {name:&#39;Kieran Culkin&#39;, born:1982})\nCREATE (Chris:Person {name:&#39;Chris Evans&#39;, born:1981})\nCREATE (Edgar:Person {name:&#39;Edgar Wright&#39;, born:1974})\nCREATE\n(Anna)-[:ACTED_IN {roles:[&#39;Stacey Pilgrim&#39;]}]-&gt;(ScottVsWorld),\n(Brie)-[:ACTED_IN {roles:[&#39;Envy Adams&#39;]}]-&gt;(ScottVsWorld),\n(Aubrey)-[:ACTED_IN {roles:[&#39;Julie Powers&#39;]}]-&gt;(ScottVsWorld),\n(Mary)-[:ACTED_IN {roles:[&#39;Ramona Flowers&#39;]}]-&gt;(ScottVsWorld),\n(Kieran)-[:ACTED_IN {roles:[&#39;Wallace Wells&#39;]}]-&gt;(ScottVsWorld),\n(Chris)-[:ACTED_IN {roles:[&#39;Lucas Lee&#39;]}]-&gt;(ScottVsWorld),\n(Edgar)-[:DIRECTED]-&gt;(ScottVsWorld);</code></pre></div>\n<p>Shouldn't be anything too surprising, just a lot of stuff being added at once.</p>\n<p>So let's do a relationship query now. Find all movies Aubrey Plaza has acted in according to our database.</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)\nWHERE p.name = &quot;Aubrey Plaza&quot;\nRETURN m.title;</code></pre></div>\n<ul>\n<li>It's actually pretty easy when you see it written out. That's one of the nice parts of Cypher is that it reads well for the most part. It can start having a lot of <code class=\"language-text\">([{}])</code> which can get to be a bit much.</li>\n<li>The <code class=\"language-text\">&gt;</code> part of <code class=\"language-text\">-&gt;</code> is optional. If you omit the direction in the query it just assumes you're saying \"find me a relationship here, I don't care which way the direction goes.\"</li>\n</ul>\n<p>One thing you'll notice is that Aubrey Plaza isn't connected to any of the other people directly, just via being attached to the same movie. What if we wanted to find every person who acted in the same movie as Aubrey (in this case everyone we've added so far.)</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">MATCH (p:Person)-[:ACTED_IN]-&gt;(Movie)&lt;-[:ACTED_IN]-(q:Person)\nWHERE p.name = &quot;Aubrey Plaza&quot; AND q.name &lt;&gt; &quot;Aubrey Plaza&quot;\nRETURN q.name;</code></pre></div>\n<ul>\n<li>There you go! We just describe out the relationship a bit further and use those variables.</li>\n<li><code class=\"language-text\">&lt;&gt;</code> is how you do not equals in Cypher</li>\n<li>Technically Aubrey was in the movie with herself? In any case we have to say don't include her in the results if we don't want to have her.</li>\n</ul>\n<p>But what if we wanted to find everyone who was younger than Aubrey that acted in the same movie?</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">MATCH (p:Person)-[:ACTED_IN]-&gt;(Movie)&lt;-[:ACTED_IN]-(q:Person)\nWHERE p.name = &quot;Aubrey Plaza&quot; AND q.born &gt; p.born\nRETURN q.name;</code></pre></div>\n<h2 id=\"constraint\" style=\"position:relative;\"><a href=\"#constraint\" aria-label=\"constraint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Constraint</h2>\n<p>Just like in the other databases you can enforce uniqueness which can be helpful. Here's how you'd do that (though a bad idea in this case because there are lots of actors, actresses, and directors named the same thing as there are multiple movies called the same thing.)</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">CREATE CONSTRAINT ON (a:Person) ASSERT a.name IS UNIQUE;\nCREATE CONSTRAINT ON (a:Movie) ASSERT a.title IS UNIQUE;</code></pre></div>","frontmatter":{"path":"/neo4j","title":"Neo4j","order":"4B","section":"Graph","description":"Graph databases are great when you need to define relations between objects that can have complex webs of relations especially for things like social networks."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"4D","path":"/complex-neo4j-queries","title":"Complex Neo4j Queries"}}},{"node":{"frontmatter":{"order":"3D","path":"/complex-sql-queries","title":"Complex SQL Queries"}}},{"node":{"frontmatter":{"order":"4A","path":"/graph-databases","title":"Graph Databases"}}},{"node":{"frontmatter":{"order":"3G","path":"/hasura","title":"Hasura"}}},{"node":{"frontmatter":{"order":"2E","path":"/indexes-in-mongodb","title":"Indexes in MongoDB"}}},{"node":{"frontmatter":{"order":"1B","path":"/installation-notes","title":"Installation Notes"}}},{"node":{"frontmatter":{"order":"3A","path":"/intro-to-sql-databases","title":"Intro to SQL Database"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"3E","path":"/json-in-postgresql","title":"JSON in PostgreSQL"}}},{"node":{"frontmatter":{"order":"2G","path":"/mongodb-ops","title":"MongoDB Ops"}}},{"node":{"frontmatter":{"order":"2B","path":"/mongodb","title":"MongoDB"}}},{"node":{"frontmatter":{"order":"4C","path":"/neo4j-browser","title":"Neo4j Browser"}}},{"node":{"frontmatter":{"order":"4F","path":"/neo4j-ops","title":"Neo4j Ops"}}},{"node":{"frontmatter":{"order":"4B","path":"/neo4j","title":"Neo4j"}}},{"node":{"frontmatter":{"order":"2F","path":"/nodejs-app-with-mongodb","title":"Write a Node.js app with MongoDB"}}},{"node":{"frontmatter":{"order":"4E","path":"/nodejs-app-with-neo4j","title":"Node.js App with Neo4j"}}},{"node":{"frontmatter":{"order":"3F","path":"/nodejs-app-with-postgresql","title":"Node.js App with PostgreSQL"}}},{"node":{"frontmatter":{"order":"2A","path":"/nosql","title":"NoSQL"}}},{"node":{"frontmatter":{"order":"3H","path":"/postgresql-ops","title":"PostgreSQL Ops"}}},{"node":{"frontmatter":{"order":"3B","path":"/postgresql","title":"PostgreSQL"}}},{"node":{"frontmatter":{"order":"2C","path":"/querying-mongodb","title":"Querying MongoDB"}}},{"node":{"frontmatter":{"order":"3C","path":"/querying-postgresql","title":"Querying PostgreSQL"}}},{"node":{"frontmatter":{"order":"1C","path":"/terminology","title":"Terminology"}}},{"node":{"frontmatter":{"order":"2D","path":"/updating-mongodb","title":"Updating MongoDB"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}