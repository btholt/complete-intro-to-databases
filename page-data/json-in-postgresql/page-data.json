{"componentChunkName":"component---src-templates-lesson-template-js","path":"/json-in-postgresql","result":{"data":{"markdownRemark":{"html":"<p>Sometimes you have data that just doesn't have a nice schema to it. If you tried to fit it into a table database like PostgreSQL, you would end having very generic field names that would have to be interprepted by code or you'd end up with multiple tables to be able describe different schemas. This is one place where document based databases like MongoDB really shine; their schemaless database works really well in these situations.</p>\n<p>However PostgreSQL has a magic superpower here: the JSON data type. This allows you to put JSON objects into a column and then you can use SQL to query those objects.</p>\n<p>Let's make an example for our message board. You want to add a new feature that allows users to do rich content embeds in your message board. For starters they'll be able to embed polls, images, and videos but you can imagine growing that in the future so they can embed tweets, documents, and other things we haven't dreamed up yet. You want to maintain that future flexibility.</p>\n<p>This would be possible to model with a normal schema but it'd come out pretty ugly and hard to understand, and it's impossible to anticipate all our future growth plans now. This is where the <code class=\"language-text\">JSON</code> data type is going to really shine. These are the queries we ran to create them. (you don't need to run them again)</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> rich_content<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> rich_content <span class=\"token punctuation\">(</span>\n  content_id <span class=\"token keyword\">INTEGER</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> GENERATED ALWAYS <span class=\"token keyword\">AS</span> <span class=\"token keyword\">IDENTITY</span><span class=\"token punctuation\">,</span>\n  comment_id <span class=\"token keyword\">INT</span> <span class=\"token keyword\">REFERENCES</span> comments<span class=\"token punctuation\">(</span>comment_id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ON</span> <span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">CASCADE</span><span class=\"token punctuation\">,</span>\n  content JSON <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> rich_content\n  <span class=\"token punctuation\">(</span>comment_id<span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">VALUES</span>\n  <span class=\"token punctuation\">(</span><span class=\"token number\">63</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'{ \"type\": \"poll\", \"question\": \"What is your favorite color?\", \"options\": [\"blue\", \"red\", \"green\", \"yellow\"] }'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token number\">358</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'{ \"type\": \"video\", \"url\": \"https://youtu.be/dQw4w9WgXcQ\", \"dimensions\": { \"height\": 1080, \"width\": 1920 }}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token number\">358</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'{ \"type\": \"poll\", \"question\": \"Is this your favorite video?\", \"options\": [\"yes\", \"no\", \"oh you\"] }'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token number\">410</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'{ \"type\": \"image\", \"url\": \"https://btholt.github.io/complete-intro-to-linux-and-the-cli/WORDMARK-Small.png\", \"dimensions\": { \"height\": 400, \"width\": 1084 }}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token number\">485</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'{ \"type\": \"image\", \"url\": \"https://btholt.github.io/complete-intro-to-linux-and-the-cli/HEADER.png\", \"dimensions\": { \"height\": 237 , \"width\": 3301 }}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>The <code class=\"language-text\">JSON</code> data type is the shining star here. This allows us to insert JSON objects to be queried later.</li>\n<li>PostgreSQL won't let you insert malformatted JSON so it does validate it for you.</li>\n<li>Notice you can have as much nesting as you want. Any valid JSON is valid here.</li>\n</ul>\n<p>So let's do some querying! We're going to use two new symbols, <code class=\"language-text\">-&gt;</code> and <code class=\"language-text\">-&gt;&gt;</code>. The <code class=\"language-text\">-&gt;</code> means \"give me back the JSON object\". The return type will be a JSON object, even if it's just a string. It's basically a black box to PostgreSQL and it treats all JSON the same, whether it's an array, object, or just a string. The <code class=\"language-text\">-&gt;&gt;</code> means \"give me this back as a string.\"</p>\n<p>Find the all the different types of rich content.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> content <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">'type'</span> <span class=\"token keyword\">FROM</span> rich_content<span class=\"token punctuation\">;</span></code></pre></div>\n<p>You'll get something like this</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token title important\"><span class=\"token punctuation\">##</span> ?column?</span>\n\n\"poll\"\n\"video\"\n\"poll\"\n\"image\"\n\"image\"</code></pre></div>\n<p>It repeats poll and image twice because there's two of those. What if we just wanted the distinct options and no repeats? GROUP BY would work but let's detour to talk about <code class=\"language-text\">SELECT DISTINCT</code>. SELECT DISTINCT will deduplicate your results for you. Try this (this will error)</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> content <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">'type'</span> <span class=\"token keyword\">FROM</span> rich_content<span class=\"token punctuation\">;</span></code></pre></div>\n<p>PostgreSQL doesn't actually know what data type it's going to get back from JSON so it refuses to do any sort of comparisons with the results. We have to tell PostgreSQL \"this is definitely going to be text.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> CAST<span class=\"token punctuation\">(</span>content <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">'type'</span> <span class=\"token keyword\">AS</span> <span class=\"token keyword\">TEXT</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> rich_content<span class=\"token punctuation\">;</span></code></pre></div>\n<p>However this is a ton easier if you just <code class=\"language-text\">-&gt;&gt;</code></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> content <span class=\"token operator\">-</span><span class=\"token operator\">>></span> <span class=\"token string\">'type'</span> <span class=\"token keyword\">FROM</span> rich_content<span class=\"token punctuation\">;</span></code></pre></div>\n<p>That's the key difference between <code class=\"language-text\">-&gt;</code> and <code class=\"language-text\">-&gt;&gt;</code>.</p>\n<p>What if we wanted to only query for polls?</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> content <span class=\"token operator\">-</span><span class=\"token operator\">>></span> <span class=\"token string\">'type'</span> <span class=\"token keyword\">AS</span> content_type<span class=\"token punctuation\">,</span> comment_id <span class=\"token keyword\">FROM</span> rich_content <span class=\"token keyword\">WHERE</span> content <span class=\"token operator\">-</span><span class=\"token operator\">>></span> <span class=\"token string\">'type'</span> <span class=\"token operator\">=</span> <span class=\"token string\">'poll'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Unfortunately due to the execution order (WHERE happens before SELECT) you can't reference content_type and have to give it the full expression.</p>\n<p>Okay, last one. What if we wanted to find all the widths and heights?</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n  content <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">'dimensions'</span> <span class=\"token operator\">-</span><span class=\"token operator\">>></span> <span class=\"token string\">'height'</span> <span class=\"token keyword\">AS</span> height<span class=\"token punctuation\">,</span>\n  content <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">'dimensions'</span> <span class=\"token operator\">-</span><span class=\"token operator\">>></span> <span class=\"token string\">'width'</span> <span class=\"token keyword\">AS</span> width<span class=\"token punctuation\">,</span>\n  comment_id\n<span class=\"token keyword\">FROM</span>\n  rich_content<span class=\"token punctuation\">;</span></code></pre></div>\n<p>You can use the <code class=\"language-text\">-&gt;</code> and <code class=\"language-text\">-&gt;&gt;</code> multiple times to look at nested values. This will give you back the ones that don't have heights and widths too. To filter those out just do:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n  content <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">'dimensions'</span> <span class=\"token operator\">-</span><span class=\"token operator\">>></span> <span class=\"token string\">'height'</span> <span class=\"token keyword\">AS</span> height<span class=\"token punctuation\">,</span>\n  content <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">'dimensions'</span> <span class=\"token operator\">-</span><span class=\"token operator\">>></span> <span class=\"token string\">'width'</span> <span class=\"token keyword\">AS</span> width<span class=\"token punctuation\">,</span>\n  comment_id\n<span class=\"token keyword\">FROM</span>\n  rich_content\n<span class=\"token keyword\">WHERE</span>\n  content <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token string\">'dimensions'</span> <span class=\"token operator\">IS</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"path":"/json-in-postgresql","title":"JSON in PostgreSQL","order":"3E","section":"SQL","description":"One of PostgreSQL's super powers is that it's able to store and query JSON"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"2F","path":"/aggregation","title":"Aggregation"}}},{"node":{"frontmatter":{"order":"4D","path":"/complex-neo4j-queries","title":"Complex Neo4j Queries"}}},{"node":{"frontmatter":{"order":"3D","path":"/complex-sql-queries","title":"Complex SQL Queries"}}},{"node":{"frontmatter":{"order":"6A","path":"/conclusion","title":"Conclusion"}}},{"node":{"frontmatter":{"order":"4A","path":"/graph-databases","title":"Graph Databases"}}},{"node":{"frontmatter":{"order":"3H","path":"/hasura","title":"Hasura"}}},{"node":{"frontmatter":{"order":"2E","path":"/indexes-in-mongodb","title":"Indexes in MongoDB"}}},{"node":{"frontmatter":{"order":"1B","path":"/installation-notes","title":"Installation Notes"}}},{"node":{"frontmatter":{"order":"3A","path":"/intro-to-sql-databases","title":"Intro to SQL Database"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"3E","path":"/json-in-postgresql","title":"JSON in PostgreSQL"}}},{"node":{"frontmatter":{"order":"5A","path":"/key-value-store","title":"Key-Value Store"}}},{"node":{"frontmatter":{"order":"2H","path":"/mongodb-ops","title":"MongoDB Ops"}}},{"node":{"frontmatter":{"order":"2B","path":"/mongodb","title":"MongoDB"}}},{"node":{"frontmatter":{"order":"5E","path":"/more-redis-concepts","title":"More Redis Concepts"}}},{"node":{"frontmatter":{"order":"4C","path":"/neo4j-browser","title":"Neo4j Browser"}}},{"node":{"frontmatter":{"order":"4E","path":"/neo4j-indexes","title":"Indexes in Neo4j"}}},{"node":{"frontmatter":{"order":"4G","path":"/neo4j-ops","title":"Neo4j Ops"}}},{"node":{"frontmatter":{"order":"4B","path":"/neo4j","title":"Neo4j"}}},{"node":{"frontmatter":{"order":"2G","path":"/nodejs-app-with-mongodb","title":"Write a Node.js app with MongoDB"}}},{"node":{"frontmatter":{"order":"4F","path":"/nodejs-app-with-neo4j","title":"Node.js App with Neo4j"}}},{"node":{"frontmatter":{"order":"3G","path":"/nodejs-app-with-postgresql","title":"Node.js App with PostgreSQL"}}},{"node":{"frontmatter":{"order":"5F","path":"/nodejs-app-with-redis","title":"Node.js App with Redis"}}},{"node":{"frontmatter":{"order":"2A","path":"/nosql","title":"NoSQL"}}},{"node":{"frontmatter":{"order":"3F","path":"/postgresql-indexes","title":"Indexes in PostgreSQL"}}},{"node":{"frontmatter":{"order":"3I","path":"/postgresql-ops","title":"PostgreSQL Ops"}}},{"node":{"frontmatter":{"order":"3B","path":"/postgresql","title":"PostgreSQL"}}},{"node":{"frontmatter":{"order":"2C","path":"/querying-mongodb","title":"Querying MongoDB"}}},{"node":{"frontmatter":{"order":"3C","path":"/querying-postgresql","title":"Querying PostgreSQL"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-command-options","title":"Redis Command Options"}}},{"node":{"frontmatter":{"order":"5D","path":"/redis-data-types","title":"Redis Data Types"}}},{"node":{"frontmatter":{"order":"5G","path":"/redis-ops","title":"Redis Ops"}}},{"node":{"frontmatter":{"order":"5B","path":"/redis","title":"Redis"}}},{"node":{"frontmatter":{"order":"1C","path":"/terminology","title":"Terminology"}}},{"node":{"frontmatter":{"order":"2D","path":"/updating-mongodb","title":"Updating MongoDB"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}